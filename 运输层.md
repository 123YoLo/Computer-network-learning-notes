# 第三章 运输层



## 本章引言：

首先是两个基础性的重要问题：1、网络层的在两个端系统之间的交付服务扩展到运行在两个不同端系统上的应用层进程之间的交付服务。2、控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复过来。

---



## 3.1概述和运输层服务

1、运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能（logic communication），应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础设施的细节。

2、运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文转化为运输层分组[**运输层报文段**(segment)]。实现的方法（可能是）将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。

**注：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段上交给运输层。运输层则将处理接收到的报文段，使报文段中的数据为接受应用进程使用。**

---



### 3.1.1 运输层和网络层的关系

网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程提供了逻辑通信。书P122~P123举了一个例子来类比两者之间的关系。

---



### 3.1.2 英特网运输层概述

前面讲到了英特网为应用层提供了两种看截然不同的可用运输层协议。一种是UDP（用户数据报协议），是一种不可靠、无连接的服务。另一种是TCP（传输控制协议），是一种可靠面向连接的服务。

TCP和UDP的分组统称为报文段。 IP的服务模型是尽力而为交付服务（best-effort delivery service）,因此它被称为是不可靠服务（unreliable service）。UDP和TCP的最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为**运输层的多路复用**与**多路分解**。

---



## 3.2 多路复用与多路分解

将运输层报文段中的数据交付到正确的套接字的工作成为**多路分解**。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将为以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为**多路复用**。

运输层多路复用的要求：1、套接字有唯一的标识符 2、每个报文段有特殊字段来指示改报文段所要指示的套接字

| 源端口号     | 目的端口号 |
| ------------ | ---------- |
| 其他首部字段 |            |
| 应用数据报文 |            |

#### 1、无连接的多路复用和多路分解

<img src="https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_01.jpg" style="zoom: 20%;transform:rotate(270deg)" />

#### 2、面向连接的多路复用和多路分解



## 3.3 无连接运输：UDP

许多应用适合用UDP的原因：

- 1、发送什么数据以及何时发送的应用层控制更为精细

- 2、无须连接建立

**注：TCP在开始建立连接之前需要三次握手，UDP无需建立连接即可数据传输**

- 3、无连接状态

**注：TCP需要在端系统中维护连接状态，包括接受和发送缓存、拥塞控制参数以及序号和确定号的参数**

- 4、分组首部开销小

#### 3.3.1 UDP报文结构

| 源端口号         | 目的端口号 |
| ---------------- | ---------- |
| 长度             | 检验和     |
| 应用数据（报文） |            |

**注：共32bit**

#### 3.3.2 UDP检验和

UDP检验和提供了差错检验（发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和中遇到的任何溢出都会被回卷，得到的结果放在UDP的检验和字段）

![](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_02.jpg)





## 3.4 可靠数据传输

![](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_03.jpg)

**注：这里rdt（reliable data transfer protocol）表示可靠数据传输协议，_send指示rdt的发送端正在被调用。在接收端，当分组从信道的接收端到达时，将调用rdt_rcv。当rdt协议想要向较高层交付数据时，将通过调用deliver_data()来完成。udt表示不可靠数据传输**

#### 3.4.1 构造可靠数据传输协议

1. 经完全可靠信道的可靠数据传输：rdt1.0

   ![d](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_04.jpg)

   **注：横线上方表示事件，下方表示动作。如果一个事件没有动作，或没有就事件发生而采取了一个动作，我们将在横线上方或下方使用符号^**

2. 经具有比特差错信道的可靠数据传输：rdt 2.0

   ![](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_05.jpg)

   - 肯定确定（positive acknowledgment,ACK）

   - 否定确定 (negative acknowledgment,NAK)

   - 自动重传请求协议（Automatic Repeat reQuest, ARQ）

   - 有限状态机（Finite-State Machine,FSM）
   
     **注：rdt2.0 的发送端有两个状态。rdt2.0仅当收到ACK并离开该状态时才能发生上面的事件，因 此rdt2.0被称为停等协议。**
   
     **ARQ处理比特差错的三种情况：**
     
     1. 差错检测（第五章会更加详细的学习）
     
     2. 接收方反馈
   
     3. 重传
     
        
     
     #### （补充）rdt2.1和rdt2.2之间的细微变化在于，接收方此时必须包括由一个ACK报文所确定的分组序号 
     
     3、经具有比特差v错的丢包信道的可靠数据传输：rdt3.0
     
     **注：协议处理关注的两个问题：1、怎样检测丢包。2、发生丢包应该做些什么**
     
     **第二个问题已经被前面的rdt技术解决了，为解决第一个问题引进了rdt3.0**
     
     
     
     发送方需要选择一个时间值来判定可能出现了丢包，重传也有可能出现**冗余数据分组（duplicate data packet）**
     
     为了实现基于时间的重传机制，需要一个**倒计数定时器**（发送方需要做到：**1、每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。2、响应定时器中断（采取适当的动作）。3、终止定时器**）
     
     ​           ![](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_06.jpg)                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
     
     
     
     
     
#### 3.4.2 流水线可靠数据传输协议（了解）

     ---


​     

## 3.5 面向连接的运输：TCP

**Tcp是因特网运输层的面向连接的可靠的运输协议。为了提供可靠的数据传输，TCP依赖于前面所讲过的许多基本原理，其中包括差错检测、重传、累积确定、定时器以及用于序号和确认号的首部字段。**



#### 3.5.1 TCP连接

1. TCP连接是一条逻辑连接
2. TCP协议只在端系统中运行
3. TCP连接总是点对点的（point-to-point）



#### 3.5.2 TCP报文段结构

  **最大报文字段长度（Maximum Segment Size,MSS）**

![7](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_07.jpg)

- 32比特的序号字段和32比特的确认号字段被TCP发送方和接收方用来实现可靠数据传输服务，详细讨论见后。

- 16比特的接受窗口字段（receive window field），该字段用于流量控制，用于指示接收方愿意接受的字节数量。
- 4比特的首部长度字段（header length field）
- 可选与变长的选项字段（options field），该字段用于发送方与接收方协商最大报文段长度（MSS），或在高速网络环境下用作窗口调节因子时使用。此外还定义了一个时间戳选项
- 6比特的标志字段（flag field）
  - **ACK比特用于指示确定字段中的值时有效的**
  - **RST表示重置连接、复位连接**
  - **SYN表示发起一个新连接**
  - **FIN表示释放一个连接**
  - **URG用来指示报文段里存在着被发送方上层置为“紧急”的数据**



1. 序号和确定号

   - **TCP报文段首部中两个最重要的字段是序号字段和确认号字段**，TCP把数据看成一个无结构的、有序的字节流。**一个报文的序号（sequence number for a segment ）**因此是该报文段首字节的字节流编号。

   - 主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号。
   - TCP提供累积确认（cumulative acknowledgement）

   

#### 3.5.3往返时间的估计与超时

#### 3.5.4 可靠数据传输

#### 3.5.5 流量控制

#### 3.5.6 TCP连接管理（3次握手（three-way handshake））

   - 第一步：客户端的TCP首先向服务器的TCP发送一个特殊的TCP报文段（该报文段被称为**SYN报文段**）另外，客户会随机地选择一个初始序号（client_isn），并将此编号放置于该起始地TCP SYN报文段的序号字段中。

   - 第二步：包含TCP SYN报文段的IP数据博爱到达服务区主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。

     **注：这个允许连接的报文段不包含应用层数据。在报文段首部包含3个重要信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn + 1。最后，服务器选择自己的初始序号（server_isn），并将其放置在TCP报文段首部的序号字段中。该允许连接的报文段被称为SYNACK报文段（SYNACK segment）**

   - 第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；着最后一个报文段对服务器的允许连接的报文段进行了确认（**该客户通过将值server_isn+1放置在TCP报文段首部的确认字段中来完成此项工作**）。因为连接已经建立好了，所以该SYN比特被置为0。

 

   ![8](https://github.com/123YoLo/Computer-network-learning-notes/blob/main/pic_08.jpg)

   

## 3.6 拥塞控制原理

拥塞会导致丢包



## 3.7 TCP拥塞控制



   

   

### 补充问题：

1、为什么要3次握手而不是2次？
